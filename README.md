# Leetcode ðŸ’»
> My algorithms practice workstation.

Here I will store my solutions to the leetcode problems, document my progress and comment the logic used. Feel free to interact ðŸ˜‰

## Roadmap

https://neetcode.io/roadmap

<img src="./imgs/roadmap.png" />

## Problems Set

### Linked Lists

- Implement a singly linked list with operations to add, delete, and display elements using pointers.
- Extend the singly linked list implementation to a doubly linked list and add reverse traversal functionality.

### Hash Tables

- **Implement a Hash Table**: Design and implement your own hash table with dynamic resizing. Focus on key insertion, deletion, and search functionalities.
- **Collision Resolution**: Extend your hash table implementation to handle collisions using chaining. Each bucket should use a linked list to store multiple entries.
- **Frequency Counter**: Write a program that uses a hash table to count the frequency of each element in a dynamic array.

### Sets

- **Implement a Set**: Create a dynamic set data structure that supports insertion, deletion, and check for existence operations efficiently.
- **Set Operations**: Implement set union, intersection, and difference operations for your dynamic set structure.
- **Subset Check**: Write a function to check if one set is a subset of another using your dynamic set implementation.


### Trees

#### Binary Trees

- **Implement a Binary Tree**: Create a binary tree structure with functions for insertion, deletion, and searching.
- **Tree Traversal**: Implement in-order, pre-order, and post-order traversal functions for your binary tree.
- **Level Order Traversal**: Write a function to perform level order traversal (breadth-first search) of a binary tree.
- **Height of a Tree**: Write a program to find the height of a binary tree.
- **Check Balanced**: Implement a function to check if a binary tree is balanced. A tree is balanced if the height of the two subtrees of any node never differ by more than one.

#### Binary Search Trees (BST)

- **Implement a BST**: Create a binary search tree with operations for insertion, search, and deletion.
- **Find Min and Max**: Write functions to find the minimum and maximum value contained in a BST.
- **Successor and Predecessor**: Implement functions to find the successor and predecessor of a given value in a BST.

#### Advanced Tree Structures

- **AVL Tree**: Implement an AVL tree, which is a self-balancing binary search tree.
- **Binary Heap**: Create a binary heap and implement operations such as insert, delete, and heapify.

### Graphs

#### Graph Representation

- **Adjacency Matrix**: Implement a graph using an adjacency matrix and perform basic operations like adding and removing an edge.
- **Adjacency List**: Represent a graph using an adjacency list and implement functions for adding and removing edges.

#### Graph Traversal

- **Depth-First Search (DFS)**: Implement DFS for a graph represented as both an adjacency matrix and an adjacency list.
- **Breadth-First Search (BFS)**: Implement BFS for a graph, ensuring it works for both representations.

#### Graph Algorithms

- **Detect Cycle**: Write a program to detect a cycle in a graph for both directed and undirected graphs.
- **Shortest Path**: Implement Dijkstra's algorithm to find the shortest path between two nodes in a graph.
- **Topological Sort**: Perform a topological sort on a directed acyclic graph (DAG).
